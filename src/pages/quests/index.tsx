import Head from "next/head";
import React, { useEffect, useState } from "react";
import Base from "../../layouts/Base";
import { Box, Container, Typography } from "@mui/material";
import { useWeb3React } from "@web3-react/core";
import QuestList from "./components/QuestList";
import Leaderboard from "./components/Leaderboard";
import { Web3Provider } from "@ethersproject/providers";
import QuestsABI from "../../contracts/Quests.json";
import { ADDRESSES } from "../../contracts/addresses";
import { ethers } from "ethers";

// Replace with your actual Quest and Player types
interface Quest {
  id: number;
  description: string;
  points: number;
  requiredTokenAddress: string;
  requiredTokenAmount: string;
  active: boolean;
}

interface Player {
  user: string;
  points: number;
}

export default function Quests() {
  const { library, account } = useWeb3React<Web3Provider>();
  const [quests, setQuests] = useState<Array<any>>([]);
  const [leaderboard, setLeaderboard] = useState<Array<any>>([]);

  useEffect(() => {
    if (!library) return;
    if (!account) return;
    fetchQuests();
    fetchLeaderboard();
  }, [library, account]);

  const fetchQuests = async () => {
    if (!library) return;
    const provider = new ethers.providers.Web3Provider(library.provider);
    const signer = provider.getSigner();
    const questContract = new ethers.Contract(
      ADDRESSES.questsAddr,
      QuestsABI.abi,
      signer
    );
    const questCount = await questContract.nextQuestId();
    const fetchedQuests: Quest[] = [];

    for (let i = 0; i < questCount; i++) {
      const questData = await questContract.quests(i);
      const quest: Quest = {
        id: questData.id,
        description: questData.description,
        points: questData.points,
        requiredTokenAddress: questData.requiredTokenAddress,
        requiredTokenAmount: ethers.utils.formatEther(
          questData.requiredTokenAmount
        ),
        active: questData.active,
      };
      fetchedQuests.push(quest);
    }

    setQuests(fetchedQuests);
  };

  async function fetchLeaderboard() {
    if (!library) return;
    const provider = new ethers.providers.Web3Provider(library.provider);
    const signer = provider.getSigner();
    const questContract = new ethers.Contract(
      ADDRESSES.questsAddr,
      QuestsABI.abi,
      signer
    );

    const rawLeaderboard = await questContract.getTop10Players();
    const leaderboard: Player[] = rawLeaderboard.map((playerData: any) => ({
      user: playerData.user,
      points: playerData.points.toNumber(),
    }));

    setLeaderboard(leaderboard);
  }

  const handleSolve = (questId: number) => {
    // Implement your solve quest logic here
    console.log(`Solve quest ${questId}`);
  };

  return (
    <>
      <Head>
        <title>Quests</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Base>
        <Container maxWidth="md">
          <Typography variant="h1">Quests</Typography>
          <Container>
            <Box sx={{ marginTop: 4 }}>
              {quests.length <= 0 ? (
                "Loading quests..."
              ) : (
                <QuestList quests={quests || []} onSolve={handleSolve} />
              )}
            </Box>
            <Box sx={{ marginTop: 4 }}>
              {quests.length <= 0 ? (
                "Loading leaderboard..."
              ) : (
                <Leaderboard leaderboard={leaderboard || []} />
              )}
            </Box>
          </Container>
        </Container>
      </Base>
    </>
  );
}
